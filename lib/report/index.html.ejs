<!DOCTYPE html>
<html>
<head>
  <title>Artillery report</title>
  <script src='https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.6.0/chart.min.js"
          integrity="sha384-scMuAXtFmPAlw0+pXLvnpHCt6VHh7AknTPdNrwiph5BA6MJWysg5WgSDl7r63txN"
          crossorigin="anonymous"></script>

  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
  <link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css' rel='stylesheet' type='text/css'>
  <link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css' rel='stylesheet' type='text/css'>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.6/moment.min.js"
          integrity="sha384-v7eExOYhwaHa3+GhP+lHytJsMcidazNdjiaggRhdbvVTVTCjweLpa23t37ZKxaCf"
          crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"
          integrity="sha384-H6KKS1H1WwuERMSm+54dYLzjg0fKqRK5ZRyASdbrI/lwrCc6bXEmtGYr5SwvP1pZ"
          crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js" charset="utf=8"
          integrity="sha384-5wv3YDwWXIxqoY02AhdpzGtKzSx7IoLw86ObEolywSYRKXx9E4rqmrU2R29LNIjR"
          crossorigin="anonymous"></script>

  <style>
  
  body, p, li {
    --bg-dark: #161616;
    --bg: #202020;
    --fg: #2B2B2B;
    --text: #ffffff;
    --text-faded: #9B9B9B;
    --border: #383838;
    --green: #24EB70;
    --yellow: #FFD600;
    --red: #ff0000;

    font-family: sans-serif;
    font-size: 10pt;
    scroll-behavior: smooth;
  }

  h1 {
    font-size: 18pt;
    font-weight: bold;
  }

  #header{
    background: var(--bg-dark);
    padding: 12px 0;
    margin-bottom: 24px;
  }

  #errorsContainer > p {
    color: var(--green);
  }

  #footer {
    padding: 1em;
    font-size: 0.8em;
    text-align: center;
    margin-top: 1em;
    color: var(--text-faded);
    background-color: var(--bg-dark);
  }
  #editor {
    font-size: 8pt;
    height: 20em;
  }
  #customCountersTable{
    width: 100%;
  }
  #customCountersTable tr{
    border-bottom: 1px solid var(--fg);
    transition: 0.2s;
  }

  #customCountersTable tr:hover{
    background: var(--fg);
  }
  td{
    padding: 4px;
  }

  .chart-wrapper{
    margin: 10px 0;
    border: 1px solid var(--border);
    border-radius: 6px;
  }
  .chart-title{
    background: var(--border);
    padding: 8px;
  }

  .chart-container {
    margin: 20px 0px;
  }
  .summary-block { 
    border: 1px solid var(--fg);
    border-radius: 4px;
    display: flex;
    align-items: center;
    padding: 4px;
    margin-right: 8px;
  }
  .index-item a{
    color: var(--text-faded);
    cursor: pointer;
    transition: 0.2s;
  }

  .index-item a:hover{
    color: var(--text);
  }
  .index-item:hover {
    color: var(--text);
    cursor: pointer;
  }
  .index-node{
    margin-left: 1rem;
    padding: 1rem;
    border-left: 1px solid var(--text-faded);
  }
  .index-parent{
    padding: 8px 2px;
  }

  .hidden{
    display: none;
  }
  .chevron-down span{
    transform: rotate(90deg);
  }
  
  </style>

  <style>
    h1 {
      line-height: 200%;
    }

    body {
      background-color: #202020;
      color: white;
      
    }

    /* .container {
      padding: 0 16px;
      width: 100%;
      min-width: 960px;
    } */
  </style>
</head>



<body>
  <%let visible="charts"%>
  
  <% const summaryInfo = [
  {icon: "&#128337;", name: "Duration", id: "testDuration"},
  {icon: "&#128337;", name: "Users Created", id: "vuCreated"},
  {icon: "&#128337;", name: "Users Completed", id: "vuCompleted"},
  <!-- {icon: "&#128337;", name: "Scenario Counts", id: "scenarioCounts"}, -->
  {icon: "&#128337;", name: "Errors", id: "errors.length"},
  ] %>

<div id="header">
<div class="container" >
  <div class="row" >
    <div class="col-lg-12">
        <h1 id="report-name">Artillery Report</h1>
        <label id="timestamp"></label>
    </div>
  </div> <!-- /.row -->
</div>
</div>
<div class="container">

  <div class="row">
    <div class="col-lg-12" style="display: flex;">
    <% for(var i=0; i < summaryInfo.length; i++){%>
    <div class="summary-block col-lg-2" >
      <div style="padding: 12px;">	
        <%= summaryInfo[i].icon %>
      </div>
      <div>
        <div style="padding: 4px 0;">
          <%= summaryInfo[i].name %>
        </div>
        <label >
          <span id="<%= summaryInfo[i].id %>">0</span> 
        </label>
      </div>
    </div>
  <% } %>
    </div>
  </div> <!-- /.row -->

<div class="row" style="margin-top: 20px;">
  <div class="col-lg-3" id="customCountersContainer" style="position: sticky; top: 20px">
    <h4>
      Counters
    </h4>
      <table id="customCountersTable">
      </table>
  </div>
  <div class="col-lg-7">
    <div id="errorsChartsRow" class="row">
      <div class="chart-container text-center col-lg-12">
        <h4>
          <i class="fas fa-chart-area"></i> Errors at intervals
        </h4>
        <canvas id="errorsAtIntervalsChart"></canvas>
      </div>
    </div>
    
    <div id="customCountersChartsRow" class="row">
      <div class="chart-container text-center col-lg-12">
        <h4>
          <i class="fas fa-chart-area"></i>Counters at intervals
        </h4>
        <div id="customCountersAtIntervalsChart"></div>
      </div>
    </div>
    
    <div id="customStats"></div>
  </div>
  <div class="col-lg-2" style="position: sticky; top: 20px;" id="index-tree">
  </div>
</div> <!-- /.row -->

<!-- <div class="row">
  <div class="text-center col-lg-12">
    <h3>Charts</h3>
  </div>
</div> -->



<div class="row">
  <div class="codes-line text-center col-lg-12"></div>
</div>
<div class="row">
  <div class="errors-line text-center col-lg-12"></div>
</div>


<div class="row">
  <div class="col-lg-8 col-lg-offset-2">
    <h3 class="text-center">Raw report data</h3>
    <p>This is the raw JSON stats output that the report was generated from.</p>
    <div id="editor">
    </div>
  </div>
</div>
</div>


<script charset="utf-8">
const Report = <%= report %>;

const editor = ace.edit("editor");
editor.getSession().setMode("ace/mode/javascript");
editor.setValue(JSON.stringify(Report, null, 2));
editor.gotoLine(1);
editor.setHighlightActiveLine(false);

let sanitizedName = Report.name.replace(/-|_/, " ").split(" ").map((w) => w[0].toUpperCase()+w.substring(1,w.length)).join(" ")
$('#report-name').html(sanitizedName)

const l = _;

$("#timestamp").html(
  moment(Report.aggregate.period).format("DD MMM YYYY HH:mm:SS")
);
// $('#testDuration').html(Math.floor((l.last(Report.intermediate).lastCounterAt - Report.intermediate[0].firstCounterAt)/1000));
$("#testDuration").html(l.size(Report.intermediate) * 10 +" sec");
$("#vuCompleted").html(Report.aggregate.counters["vusers.completed"]);
$("#vuCreated").html(Report.aggregate.counters["vusers.created"]);

const chartBgColors = {
  red: "rgba(255, 99, 132, 0.2)",
  orange: "rgba(255, 159, 64, 0.2)",
  yellow: "rgba(255, 205, 86, 0.2)",
  green: "rgba(75, 192, 192, 0.2)",
  blue: "rgba(54, 162, 235, 0.2)",
};

const chartBorderColors = {
  red: "rgb(255, 99, 132)",
  orange: "rgb(255, 159, 64)",
  yellow: "rgb(255, 205, 86)",
  green: "rgb(75, 192, 192)",
  blue: "rgb(54, 162, 235)",
};

const getHttpColor = (httpCode) => {
  const code = parseInt(httpCode, 10);

  if (code >= 100 && code < 200) {
    return chartBorderColors.blue;
  } else if (code >= 200 && code < 300) {
    return chartBorderColors.green;
  } else if (code >= 300 && code < 400) {
    return chartBorderColors.red;
  } else if (code >= 400 && code < 500) {
    return chartBorderColors.yellow;
  }

  return chartBorderColors.orange;
}

const getLatencyColor = (latency) => {
  switch(latency) {
    case "min":
      return chartBorderColors.red;
    case "max":
      return chartBorderColors.orange;
    case "median":
      return chartBorderColors.yellow;
    case "p95":
      return chartBorderColors.green;
    case "p99":
      return chartBorderColors.green;
    default:
      return '';
  }
};

const getCustomStats = (stats) =>
  l.omitBy(
    stats,
    (_, key) =>
      key.startsWith("errors.") ||
      key.startsWith("core.") ||
      key.startsWith("engine.")
  );

const scenarioCounts = l.pickBy(Report.aggregate.counters, (_, key) =>
  key.startsWith("vusers.created_by_name")
);

if (l.size(scenarioCounts) > 0) {
  l.each(scenarioCounts, function (count, key) {
    const [, , name] = key.split(".");

    const $tdName = $("<td>" + name + "</td>");
    const percentage =
      Math.round(
        (count / Report.aggregate.counters["vusers.created"]) *
          100 *
          1000
      ) / 1000;
    const $tdCount = $("<td>" + count + " (" + percentage + "%)" + "</td>");
    $("<tr></tr>")
      .append($tdName)
      .append($tdCount)
      .appendTo($("#scenarioCounts"));
  });
} else {
  $("#scenarioCountsContainer").hide();
}

const httpCodes = l.pickBy(Report.aggregate.counters, (_, key) =>
  key.startsWith("http.codes")
);

const errors = l.pickBy(Report.aggregate.counters, (_, key) =>
  key.startsWith("errors.")
);
if (l.size(errors) > 0) {
  l.each(errors, function (count, error) {
    const [, errorDetail] = error.split("errors.");

    $("<tr></tr>")
      .append($("<td>" + errorDetail + "</td>"))
      .append($("<td>" + count + "</td>"))
      .appendTo($("#errors"));
  });
} else {
  $("#errorsContainer > p").html(
    "&#10004; Test completed without network or OS errors."
  );
}

const getTimePeriodAggregates = (summaries) => {
  const summary =
    summaries["socketio.response_time"] ||
    summaries["http.response_time"];
  const metrics = ["min", "max", "median", "p95", "p99"];

  return l.pickBy(summary, (_, key) => metrics.includes(key));
};

const getLatencyDistribution = (data) => {
  return l.reduce(
    data,
    (acc, value, key) => {
      acc.labels.push(key);
      acc.values.push(value);

      return acc;
    },
    { labels: [], values: [] }
  );
};

const randomRgbColor = () => {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);

  return "rgb(" + r + ", " + g + ", " + b + ")";
};

const latencyDistributionData = getLatencyDistribution(
  getTimePeriodAggregates(Report.aggregate.summaries)
);

const latencyAtIntervalsData = (intermediates = []) => {
  const data = intermediates.reduce(
    (acc, entry, idx) => {
      const latencies = getTimePeriodAggregates(entry.summaries);

      l.each(latencies, (latency, key) => {
        acc.values[key] = acc.values[key] || [];

        acc.values[key].push(latency);
      });

      acc.labels.push((idx + 1) * 10);

      return acc;
    },
    { labels: [], values: {} }
  );

  return {
    labels: data.labels,
    datasets: l.map(data.values, (entry, key) => {
      const color = getLatencyColor(key);

      return {
        label: key,
        data: entry,
        fill: false,
        backgroundColor: color,
        borderColor: color,
        tension: 0.5,
      };
    })
  };
};

const getCounterDataset = (intermediates = [], counterKeys) => {
  let counterKey = "";

  if (intermediates[0]) {
    for (const key of counterKeys) {
      if (key in intermediates[0].counters) {
        counterKey = key;
        break;
      }
    }
  }

  const data = intermediates.reduce(
    (acc, entry, idx) => {
      const count = entry.counters[counterKey] || 0;

      acc.labels.push((idx + 1) * 10);
      acc.values.push(count);

      return acc;
    },
    { labels: [], values: [] }
  );

  return {
    labels: data.labels,
    datasets: [
      {
        data: data.values,
        fill: false,
        borderColor: randomRgbColor(),
        tension: 0.5,
      },
    ],
  };
};

const getMeanRpsData = (intermediates = []) => {
  const data = intermediates.reduce(
    (acc, entry, idx) => {
      const count =
        entry.rates["http.request_rate"] ||
        entry.rates["socketio.emit_rate"] ||
        entry.rates["websocket.send_rate"] ||
        0;

      acc.labels.push((idx + 1) * 10);
      acc.values.push(count);

      return acc;
    },
    { labels: [], values: [] }
  );

  return {
    labels: data.labels,
    datasets: [
      {
        data: data.values,
        fill: false,
        borderColor: randomRgbColor(),
        tension: 0.5,
      },
    ],
  };
};

const getHttpCodesAtIntervalsData = (intermediates = []) => {
  const data = intermediates.reduce(
    (acc, entry, idx) => {
      const httpCodes = l.pickBy(entry.counters, (_, key) =>
        key.startsWith("http.codes")
      );

      if (l.size(httpCodes) > 0) {
        l.each(httpCodes, (count, key) => {
          let [, , , code] = key.split(".");
          code = parseInt(code, 10);

          acc.values[code] = acc.values[code] || [];

          acc.values[code].push(count);
        });
      }

      acc.labels.push((idx + 1) * 10);

      return acc;
    },
    { labels: [], values: {} }
  );

  return {
    labels: data.labels,
    datasets: l.map(data.values, (entry, key) => {
      const color = getHttpColor(key);

      return {
        label: key,
        data: entry,
        fill: false,
        backgroundColor: color,
        borderColor: color,
        tension: 0.5,
      };
    }),
  };
};

const getHttpCodesData = (counters) => {
  const httpCodes = l.pickBy(counters, (_, key) =>
    key.startsWith("http.codes")
  );
  const labels = [];
  const data = [];
  const bgColors = [
    "rgba(54, 232, 235, 0.5)",
    "rgba(54, 235, 93, 0.5)",
    "rgba(229, 235, 54, 0.5)",
    "rgba(166, 54, 235, 0.5)",
    "rgba(235, 54, 69, 0.5)",
  ];

  if (l.size(httpCodes) > 0) {
    l.each(httpCodes, function (count, key) {
      let [, , , code] = key.split(".");
      code = parseInt(code, 10);

      labels.push(code);
      data.push(count);
    });
  }

  return {
    labels,
    datasets: [
      {
        backgroundColor: labels.map(getHttpColor),
        hoverOffset: 4,
        data,
      },
    ],
  };
};

if (l.size(errors) > 0) {
  const getErrorsAtIntervalsData = (intermediates = []) => {
    const data = intermediates.reduce(
      (acc, entry, idx) => {
        const errorsCounters = l.pickBy(entry.counters, (_, key) =>
          key.startsWith("errors.")
        );

        l.each(errorsCounters, (count, key) => {
          const [, errorDetail] = key.split("errors.");

          acc.values[errorDetail] = acc.values[errorDetail] || [];

          acc.values[errorDetail].push(count);
        });

        acc.labels.push((idx + 1) * 10);

        return acc;
      },
      { labels: [], values: {} }
    );

    return {
      labels: data.labels,
      datasets: l.map(data.values, (entry, key) => {
        return {
          label: key,
          data: entry,
          fill: false,
          backgroundColor: Object.values(chartBgColors),
          borderColor: Object.values(chartBorderColors),
          tension: 0.5,
        };
      })
    };
  };


  new Chart(document.getElementById("errorsAtIntervalsChart"), {
    type: "line",
    data: getErrorsAtIntervalsData(Report.intermediate),
    options: {
      plugins: { legend: { position: "bottom" } },
      aspectRatio: 3.5,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "ms",
          },
        },
      },
    },
  });
} else {
  $("#errorsChartsRow").hide();
}

const customCounters = getCustomStats(Report.aggregate.counters);

if (l.size(customCounters) > 0) {
  let rows = [];
  l.each(customCounters, function (count, key) {
    const row = $("<tr></tr>")
      .append($("<td>" + key + "</td>"))
      .append($("<td>" + count + "</td>"));
    rows.push(row);
  });

  if (rows.length > 5) {
    const visibleRows = rows.slice(0, 5);
    const hiddenRows = rows.slice(5).map((row) => row.addClass("hidden"));
    rows = [
      ...visibleRows,
      $(
        '<tr id="expandCustomCountersRow"><td class="text-center" colspan="2"><a href="" id="expandCustomCounters">+'+ hiddenRows.length+ ' more</a></td></tr>'
      ),
      ...hiddenRows,
    ];
  }

  rows.forEach((row) => row.appendTo($("#customCountersTable")));

  if (rows.length > 5) {
    $("#expandCustomCountersRow").on("click", (e) => {
      e.preventDefault();

      $("#customCountersTable tr").removeClass("hidden");
      $("#expandCustomCountersRow").addClass("hidden");
    });
  }

  const getCustomStatsAtIntervalsData = (intermediates = []) => {
    const data = intermediates.reduce(
      (acc, entry, idx) => {
        const customCounters = getCustomStats(entry.counters);

        l.each(customCounters, (count, key) => {
          acc.values[key] = acc.values[key] || [];
          acc.values[key].push(count);
        });

        acc.labels.push((idx + 1) * 10);
        return acc;
      },
      { labels: [], values: {} }
    );

    return {
      labels: data.labels,
      datasets: l.map(data.values, (entry, key) => {
        color = randomRgbColor();

        return {
          label: key,
          data: entry,
          fill: false,
          backgroundColor: color,
          borderColor: color,
          tension: 0.5,
        };
      }),
    };
  };


// parse out index tabs from custom counters for index nav
const indexTabs = Array.from(new Set(Object.keys(customCounters).map((c) => c.match(/^([^.]+)/)[0])))

// create tree from index tabs
const indexTree = indexTabs.reduce((key, value) => {
  return {...key, [value]: []};
}, {});

// fill tree with custom counters according to parent tab
Object.keys(customCounters).forEach((counter)=> {
  const parent = counter.match(/^([^.]+)/)[0]
  indexTree[parent].push(counter.match(/\.(.*)/)[1])
})


// populate index with divs
let $htmlTree = $('<div style="color: var(--text-faded);"><div style="padding: 4px 0; border-bottom: 1px solid var(--text-faded);">Index<div></div>')
Object.keys(indexTree).forEach((parent)=> {
  const nodes = indexTree[parent].map((n)=> 
      '<div class="'+parent+'-node index-item index-node hidden" ><a href="#'+parent+"."+n+'-wrapper" id="'+n+'-node" >'+n+'</a></div>').join("")
  $htmlTree.append(
    '<div id="'+parent+'-parent" > <div onclick="tabClick(`'+parent+'`)" class="index-item index-parent" style="display: flex;align-items: center;">'+
      '<span style="font-size: 2rem; padding-right: 1rem; transition: 0.2s;">&rsaquo;</span>'//chevron
      +parent+' ('+indexTree[parent].length+') </div>'+
      nodes+
    '</div>'
  )
})
const indexTreeContainer = $("#index-tree")
$htmlTree.appendTo(indexTreeContainer)

function tabClick(tab) {
  const nodeClass = '.'+tab+'-node'
  const nodes = document.querySelectorAll(nodeClass);
  const parentTab = document.getElementById(tab+"-parent");
  [...parentTab.classList].includes('chevron-down')? parentTab.classList.remove('chevron-down') : parentTab.classList.add('chevron-down');
  for (const node of nodes) {
    [...node.classList].includes("hidden")? node.classList.remove("hidden") : node.classList.add("hidden");
  }
}


$("#expandCustomCountersRow").on("click", (e) => {
      e.preventDefault();

      $("#customCountersTable tr").removeClass("hidden");
      $("#expandCustomCountersRow").addClass("hidden");
    });



  customCharts = []  
  // add line charts to chart list
  Object.keys(Report.intermediate[0].counters).forEach((chart)=> {
      let newChart = {name: chart, type: 'line', data: []}
      for(i=0; i < Report.intermediate.length; i++) {
        let newCounter = { [chart]: Report.intermediate[i].counters[chart]}
        
        newChart.data.push({counters: newCounter})
      }
      customCharts.push(newChart)
  })


  Object.keys(Report.aggregate.histograms).forEach((h)=> {
    let newHistogram = {name: h, type: 'bar', data: Report.aggregate.summaries[h]}
    customCharts.push(newHistogram)
  })



  customCharts.forEach((chart)=> {
    $('#customCountersAtIntervalsChart').append("<div id='"+chart.name+"-wrapper' class='chart-wrapper'><div class='chart-title'>"+chart.name+"</div><canvas style='padding: 8px' id='"+chart.name+"'></canvas></div>")
    if(chart.type==='line'){
    new Chart(document.getElementById(chart.name), {
    type: chart.type,
    data: getCustomStatsAtIntervalsData(chart.data),
    options: {
      plugins: { legend: { display: false } },
      aspectRatio: 2.5,
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "ms",
          },
        },
      },
    },
    });
  } else if (chart.type === 'bar'){
    const { labels, values } = getLatencyDistribution(
      l.pickBy(chart.data, (_, key) =>
        ["min", "max", "median", "p95", "p99"].includes(key)
      )
    );
    new Chart(document.getElementById(chart.name), {
      type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              data: values,
              backgroundColor: Object.values(chartBgColors),
              borderColor: Object.values(chartBorderColors),
              borderWidth: 1,
            },
          ],
        },
        options: {
          plugins: { legend: { display: false } },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "ms",
              },
            },
          },
        },
    })
  }
  })
} else {
  $("#customCountersChartsRow").hide();
  $("#customCountersContainer").hide();
}


</script>
<div id="footer">
  <footer>This report was created with <a href="https://artillery.io">Artillery</a> - free open-source load-testing for HTTP and WebSockets</footer>
</div>

</body>
</html>
